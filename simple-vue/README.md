# 极简版vue

之前做到了这个题目，但是感觉实现的很烂，所以重新做了一遍，参（chao）考（xi）了vue1.x的源码，重点关注的是双向数据绑定的实现，说说思路吧

重点是Observer, Dep, Watcher, Compile这几个构造函数

Observer： 改造数据对象，使set和get能够被监听，然后我们就能做一些事情了

Dep: 依赖容器，每个数据对应一个Dep容器，它存在于闭包之中，在改造数据的时候被创建，容器里装的是watcher，watcher在数据get的时候被隐式添加进dep。

watcher: 观察者，当数据的set被触发的时候，依次调用该数据dep容器里的watcher的更新函数，这样就能实现视图和数据的更新。

compile: 编译函数，在初始化的时候，遍历dom各节点，对每个有模板或者命令的节点都创建一个watcher，并绑定该节点与watcher的关系，这样更新的时候就能精确的更新某个节点了，但是这个watcher如何添加进Dep依赖容器里呢，答案就是创建watcher的时候，watcher里会获取一次数据的值，触发get，watcher就被隐式添加到Dep里了。

vue源码有很多精妙之处，让人大开眼界，比如：

* 依赖的添加，通过一个全局变量Dep.target来添加。以及隐式添加依赖
* 如何通过路径，如 user.name 获取值，我原来是把这个拆开成user,name,然后通过递归获取，但源码直接用一个匿名函数return scope.user.name 把vm传进去，直接获取vm.user.name。多简单
* compile函数的写法，转换成文档碎片。
* Dep依赖容器存放于闭包之中，之前一直不知道如果要每个数据对应一个依赖容器的话，这个容器应该放在哪。

待改进：

- ~~模版的解析不支持 {{user.name}}11 ，这样解析完后11会消失。~~
	
	思路：新建一个文档碎片，替换原文本。比如{{user.name}}111{{user.age}}，用正则匹配后，创建三个新节点加入文档碎片，再用文档碎片替换原textnode，是模板的就会创建watcher，将该节点与数据绑定起来。这样原来只有一个文本节点，现在就有三个，并且各不干扰

- ~~批处理dom~~

	目的：新建一个批处理类，它的作用是保证对于一个数据，不管它变化了多少次，对DOM的更新只进行一次。
	```javascript
	//比如这三条同步语句，我们需要做到只更新一次DOM，令user.name = 'c'
	user.name = 'a'; 
	user.name = 'b';
	user.name = 'c'
	```	

	主要思路：拿上面的代码举例，每次更改数据的时候，都会执行watcher的update函数，现在我们不直接在update里更新DOM，而是把watcher交给批处理类，让它决定怎么更新。既然要只更新一次，那么批处理的队列里只能有一个更新函数。而我们修改了三次数据，就交给了批处理类三次watcher。怎么保证只有一个更新函数呢？虽然修改了三次数据，但是这三次的数据的watcher是同一个，所以我们用它的id来保证更新函数的唯一性。当push的时候，检查是否存在相同id的watcher，不存在就添加进队列，存在就不处理。所以这个watcher的更新函数只会有一个。注意我们使用了setTimeout(function(){},0)，这个的意思是等待主线程执行完毕之后才执行更新，所以更新函数的执行总是在修改数据之后，这就保证了更新的是最新的数据。

- 数组处理

至于vue2.x的virtual dom，还得研究研究...